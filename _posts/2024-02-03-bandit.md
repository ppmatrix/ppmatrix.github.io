---
layout: post
title: Bandit
categories: [CyberSecurity, CTF, Wargames]
tags: [thm, easy, nmap]
---
![Bandit](./assets/bandit.png){: .right }{: w="200" h="200" }
## Walkthrough
[https://overthewire.org/wargames/bandit/](https://overthewire.org/wargames/bandit/)

## Level 0

### Task
The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is **bandit0** and the password is **bandit0**. Once logged in, go to the Level 1 page to find out how to beat Level 1.

### Login
Login as the descripted in task:

```bash
ssh bandit0@bandit.labs.overthewire.org -p 2220
password:bandit0
```
{: .nolineno }

## Level 0 -> Level 1

### Task
The password for the next level is stored in a file called readme located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game.

### MyWalk
As the description:

```bash
bandit0@bandit:~$ ls -al
total 24
drwxr-xr-x  2 root    root    4096 Oct  5 06:19 .
drwxr-xr-x 70 root    root    4096 Oct  5 06:20 ..
-rw-r--r--  1 root    root     220 Jan  6  2022 .bash_logout
-rw-r--r--  1 root    root    3771 Jan  6  2022 .bashrc
-rw-r--r--  1 root    root     807 Jan  6  2022 .profile
-rw-r-----  1 bandit1 bandit0   33 Oct  5 06:19 readme
bandit0@bandit:~$ cat readme
NH2SXQwcBdpmTEzi3bvBHMM9H66vVXjL
```
{: .nolineno }

## Level 1 -> Level 2

### Login
```bash
ssh bandit1@bandit.labs.overthewire.org -p 2220
password:NH2SXQwcBdpmTEzi3bvBHMM9H66vVXjL
```
{: .nolineno }

### Task
The password for the next level is stored in a file called - located in the home directory

### MyWalk
This type of approach has a lot of misunderstanding because using - as an argument refers to STDIN/STDOUT i.e dev/stdin or dev/stdout .So if you want to open this type of file you have to specify the full location of the file such as ./- .For eg. , if you want to see what is in that file use cat ./-

```bash
bandit1@bandit:~$ ls -al
total 24
-rw-r-----  1 bandit2 bandit1   33 Oct  5 06:19 -
drwxr-xr-x  2 root    root    4096 Oct  5 06:19 .
drwxr-xr-x 70 root    root    4096 Oct  5 06:20 ..
-rw-r--r--  1 root    root     220 Jan  6  2022 .bash_logout
-rw-r--r--  1 root    root    3771 Jan  6  2022 .bashrc
-rw-r--r--  1 root    root     807 Jan  6  2022 .profile
bandit1@bandit:~$ cat ./-
rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi
```
{: .nolineno }

Another way is using redirection:
```bash
bandit1@bandit:~$ cat < -
rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi
```
{: .nolineno }

Also using the **rev** command.  
The rev utility copies the specified files to standard output, reversing the order of characters in every line.  
So this shows what's in the file in the correct order:
```bash
bandit1@bandit:~$ rev - | rev
rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi
```
{: .nolineno }

Helpful Reading Material:  
Google Search for “dashed filename”  
Advanced Bash-scripting Guide - Chapter 3 - Special Characters

## Level 2 -> Level 3

### Login
```bash
ssh bandit2@bandit.labs.overthewire.org -p 2220
password:rRGizSaX8Mk1RTb1CNQoXTcYZWU6lgzi
```
{: .nolineno }

### Task
The password for the next level is stored in a file called spaces in this filename located in the home directory

### MyWalk
Simply using commas:

```bash
bandit2@bandit:~$ ls -al
total 24
drwxr-xr-x  2 root    root    4096 Oct  5 06:19 .
drwxr-xr-x 70 root    root    4096 Oct  5 06:20 ..
-rw-r--r--  1 root    root     220 Jan  6  2022 .bash_logout
-rw-r--r--  1 root    root    3771 Jan  6  2022 .bashrc
-rw-r--r--  1 root    root     807 Jan  6  2022 .profile
-rw-r-----  1 bandit3 bandit2   33 Oct  5 06:19 spaces in this filename
bandit2@bandit:~$ cat "spaces in this filename"
aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG
```
{: .nolineno }

## Level 3 -> Level 4

### Login
```bash
ssh bandit3@bandit.labs.overthewire.org -p 2220
password:aBZ0W5EmUfAf7kHTQeOwd8bauFJ2lAiG
```
{: .nolineno }

### Task
The password for the next level is stored in a hidden file in the inhere directory.

### MyWalk
```bash
bandit3@bandit:~$ ls -al
total 24
drwxr-xr-x  3 root root 4096 Oct  5 06:19 .
drwxr-xr-x 70 root root 4096 Oct  5 06:20 ..
-rw-r--r--  1 root root  220 Jan  6  2022 .bash_logout
-rw-r--r--  1 root root 3771 Jan  6  2022 .bashrc
drwxr-xr-x  2 root root 4096 Oct  5 06:19 inhere
-rw-r--r--  1 root root  807 Jan  6  2022 .profile
bandit3@bandit:~$ cd inhere
bandit3@bandit:~/inhere$ ls -al
total 12
drwxr-xr-x 2 root    root    4096 Oct  5 06:19 .
drwxr-xr-x 3 root    root    4096 Oct  5 06:19 ..
-rw-r----- 1 bandit4 bandit3   33 Oct  5 06:19 .hidden
bandit3@bandit:~/inhere$ cat .hidden
2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe
```
{: .nolineno }

## Level 4 -> Level 5

### Login
```bash
ssh bandit4@bandit.labs.overthewire.org -p 2220
password:2EW7BBsr6aMMoJ2HjW067dm8EgX26xNe
```
{: .nolineno }

### Task
The password for the next level is stored in the only human-readable file in the inhere directory. Tip: if your terminal is messed up, try the “reset” command.

### MyWalk
```bash
bandit4@bandit:~/inhere$ ls -al
total 48
drwxr-xr-x 2 root    root    4096 Oct  5 06:19 ./
drwxr-xr-x 3 root    root    4096 Oct  5 06:19 ../
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file00
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file01
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file02
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file03
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file04
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file05
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file06
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file07
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file08
-rw-r----- 1 bandit5 bandit4   33 Oct  5 06:19 -file09
bandit4@bandit:~/inhere$ cat < -file01
7L3��Y�ͯ	Ŵ����E�Y�ܚ	�V&��h�F�bandit4@bandit:~/inhere$ 
```
{: .nolineno }

After trying some files we get:
```bash
bandit4@bandit:~/inhere$ cat < -file07
lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR
```
{: .nolineno }

## Level 5 -> Level 6

### Login
```bash
ssh bandit5@bandit.labs.overthewire.org -p 2220
password:lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR
```
{: .nolineno }

### Task
The password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties:
- human-readable
- 1033 bytes in size
- not executable

### MyWalk
I search for commands to search files based on file size and found the following site:  
[https://linuxconfig.org/how-to-use-find-command-to-search-for-files-based-on-file-size](https://linuxconfig.org/how-to-use-find-command-to-search-for-files-based-on-file-size)


```bash
bandit5@bandit:~/inhere$ ls -al
total 88
drwxr-x--- 22 root bandit5 4096 Oct  5 06:19 .
drwxr-xr-x  3 root root    4096 Oct  5 06:19 ..
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere00
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere01
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere02
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere03
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere04
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere05
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere06
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere07
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere08
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere09
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere10
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere11
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere12
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere13
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere14
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere15
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere16
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere17
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere18
drwxr-x---  2 root bandit5 4096 Oct  5 06:19 maybehere19
bandit5@bandit:~/inhere$ find -size 1033c
./maybehere07/.file2
bandit5@bandit:~/inhere$ cat ./maybehere07/.file2
P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU
```
{: .nolineno }

## Level 6 -> Level 7

### Login
```bash
ssh bandit6@bandit.labs.overthewire.org -p 2220
password:P4L4vucdmLnm8I7Vl7jG1ApGSfjYKqJU
```
{: .nolineno }

### Task
The password for the next level is stored somewhere on the server and has all of the following properties:
- owned by user bandit7
- owned by group bandit6
- 33 bytes in size

### MyWalk
We use the **find** command with the following options:

-type f, because we are looking for a file  
-user bandit7, to find files owned by the ‘bandit7’ user  
-group bandit6, to find files owned by the ‘bandit6’ group  
-size 33c, to find files of size 33 bytes  
We need to run the command from the root directory to search the whole  system. Running the command find / -type f -user bandit7 -group bandit6 -size 33c will, however, also print a Permission denied error for files that we do not have permission. We can append 2>/dev/null, which will ‘hide’ all error messages 1.

And we got the file and can read the next password:
```bash
bandit6@bandit:/home$ find / -type f -user bandit7 -group bandit6 -size 33c 2>/dev/null
/var/lib/dpkg/info/bandit7.password
bandit6@bandit:/home$ cat /var/lib/dpkg/info/bandit7.password
z7WtoNQU2XfjmMtWA8u5rN4vzqu4v99S
```
{: .nolineno }

## Level 7 -> Level 8

### Login
```bash
ssh bandit7@bandit.labs.overthewire.org -p 2220
password:z7WtoNQU2XfjmMtWA8u5rN4vzqu4v99S
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt next to the word millionth

### MyWalk
First we search for the data.txt and then locate the password in file:

```bash
bandit7@bandit:/home$ find / -type f -name data.txt 2>/dev/null
/home/bandit9/data.txt
/home/bandit10/data.txt
/home/bandit7/data.txt
/home/bandit11/data.txt
/home/bandit12/data.txt
/home/bandit8/data.txt
bandit7@bandit:/home$ grep millionth /home/bandit7/data.txt
millionth	TESKZC0XvTetK0S9xNwm25STk5iWrBvP
```
{: .nolineno }

## Level 8 -> Level 9

### Login
```bash
ssh bandit8@bandit.labs.overthewire.org -p 2220
password:TESKZC0XvTetK0S9xNwm25STk5iWrBvP
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt and is the only line of text that occurs only once.

### MyWalk
The **uniq** command in Linux is a command-line utility that reports or filters out the repeated lines in a file.  
[https://www.geeksforgeeks.org/uniq-command-in-linux-with-examples/](https://www.geeksforgeeks.org/uniq-command-in-linux-with-examples/)

First we find the file, based on name, and then use **uniq** with -u flag:
```bash
bandit8@bandit:~$ find / -type f -name data.txt 2>/dev/null
/home/bandit9/data.txt
/home/bandit10/data.txt
/home/bandit7/data.txt
/home/bandit11/data.txt
/home/bandit12/data.txt
/home/bandit8/data.txt
bandit8@bandit:~$ sort /home/bandit8/data.txt | uniq -u
EN632PlfYiZbn3PhVK3XOGSlNInNE00t
```
{: .nolineno }

## Level 9 -> Level 10

### Login
```bash
ssh bandit9@bandit.labs.overthewire.org -p 2220
password:EN632PlfYiZbn3PhVK3XOGSlNInNE00t
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt in one of the few human-readable strings, preceded by several ‘=’ characters.

### MyWalk
we will **grep** it from string:
```bash
bandit9@bandit:~$ strings /home/bandit9/data.txt | grep ==
x]T========== theG)"
========== passwordk^
========== is
========== G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s
```
{: .nolineno }

## Level 10 -> Level 11

### Login
```bash
ssh bandit10@bandit.labs.overthewire.org -p 2220
password:G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt, which contains **base64** encoded data

### MyWalk
We will decoded the **base64**:
```bash
bandit10@bandit:~$ base64 -d /home/bandit10/data.txt
The password is 6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM
```
{: .nolineno }

## Level 11 -> Level 12

### Login
```bash
ssh bandit11@bandit.labs.overthewire.org -p 2220
password:6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions

### MyWalk
We will rotate by 13 with command **tr**:
```bash
bandit11@bandit:~$ cat /home/bandit11/data.txt | tr 'n-za-mN-ZA-M' 'a-zA-Z'
The password is JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv
```
{: .nolineno }

## Level 12 -> Level 13

### Login
```bash
ssh bandit12@bandit.labs.overthewire.org -p 2220
password:JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv
```
{: .nolineno }

### Task
The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!)

### MyWalk
Let's create the directory and move the data.txt:
```bash
bandit12@bandit:~$ mkdir /tmp/ppm
bandit12@bandit:~$ cd /tmp/ppm
bandit12@bandit:/tmp/ppm$ cp ~/data.txt .
bandit12@bandit:/tmp/ppm$ ls
data.txt
```
{: .nolineno }

We know the data.txt is a hexdump of a file so lets rename it for easy recognition:

```bash
bandit12@bandit:/tmp/ppm$ mv data.txt hexdump_data
bandit12@bandit:/tmp/ppm$ ls
hexdump_data
```
{: .nolineno }
We can see how a hexdump file looks like:

```bash
bandit12@bandit:/tmp/ppm$ cat hexdump_data | head
00000000: 1f8b 0808 6855 1e65 0203 6461 7461 322e  ....hU.e..data2.
00000010: 6269 6e00 013d 02c2 fd42 5a68 3931 4159  bin..=...BZh91AY
00000020: 2653 5948 1b32 0200 0019 ffff faee cff7  &SYH.2..........
00000030: f6ff e4f7 bfbc ffff bff7 ffb9 39ff 7ffb  ............9...
00000040: bd31 eeff b9fb fbbb b9bf f77f b001 3b2c  .1............;,
00000050: d100 0d03 d200 6868 0d00 0069 a00d 0340  ......hh...i...@
00000060: 1a68 00d0 0d01 a1a0 0001 a680 0003 46d4  .h............F.
00000070: 6434 3234 611a 340d 07a4 c351 068f 5000  d424a.4....Q..P.
00000080: 069a 0680 0000 0006 8006 8da4 681a 6868  ............h.hh
00000090: 0d06 8d00 6834 3400 d07a 9a00 01a0 0341  ....h44..z.....A
```
{: .nolineno }

Now we will revert the hexdump:

```bash
bandit12@bandit:/tmp/ppm$ xxd -r hexdump_data compressed_data
bandit12@bandit:/tmp/ppm$ ls
compressed_data  hexdump_data
```
{: .nolineno }

Looking into the reverted file:

```bash
bandit12@bandit:/tmp/ppm$ cat compressed_data | head
�h44�z��A����@=�h4hh�▒▒��4�i��1����▒��hd����9���1����������;,�
�����2�3d*58�~  �S�▒ZP^��luY��Br$�FP!%�s��h�?�)[=�h��O(B��2A���)�tZc��:�pã)�A�ˈ�0���΅A�yjeϢx,�(����z�E�+"�2�/�-��e"���^����t�j���$�d�@�dJơ'7\���$��m1c��#>�aԽ�EV��F��OCӐc@M�C���]��Y2^h8���D=��~   O�I��NDpF�+�|b#Jv�#�J��d�LފW$�Û�▒y�`          
```
{: .nolineno }

As described in task this is a multiple time compressed file, so we need to know the compression filetype of the actual compression. For that we will verify the first bytes in the hexdump_data file and compare it with the file signatures list at [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures).

```bash
bandit12@bandit:/tmp/ppm$ head -n 1 hexdump_data
00000000: 1f8b 0808 6855 1e65 0203 6461 7461 322e  ....hU.e..data2.         
```
{: .nolineno }

Searching for "1f" in the list of file sugnatures page, we cant identify "1f 8b" as a **GZIP** compressed file signature. The extension for this filetype is ".gz", so will rename the file accordingly, because for **GZIP** it's mandatory to have the ".gz" file extension:

```bash
bandit12@bandit:/tmp/ppm$ mv compressed_data compressed_data.gz
bandit12@bandit:/tmp/ppm$ ls
compressed_data.gz  hexdump_data        
```
{: .nolineno }

Decompress now using the **GZIP**:

```bash
bandit12@bandit:/tmp/ppm$ gzip -d compressed_data.gz
bandit12@bandit:/tmp/ppm$ ls
compressed_data  hexdump_data
```
{: .nolineno }

We have now a compressed_data file which is in a previous stage of compression. Lets check if is true:

```bash
cat compressed_data | head
�h44�z��A����@=�h4hh�▒▒��4�i��1����▒��hd����;,�
�����2�3d*58�~  �S�▒ZP^��luY��Br$�FP!%�s��h�?�)[=�h��O(B��2A���)�tZc��:�pã)�A�ˈ�0���΅A�yjeϢx,�(����z�E�+"�2�/�-��e"�
```
{: .nolineno }

It's still compressed as we can see.  
So now we need to check the file signature again. For that we need to see the hexdump of the file:

```bash
bandit12@bandit:/tmp/ppm$ xxd compressed_data
00000000: 425a 6839 3141 5926 5359 481b 3202 0000  BZh91AY&SYH.2...
```
{: .nolineno }

Searching for "42" we can found "42 5A 68" signature to "Compressed file using Bzip2 algorithm". This file use the ".bz2" extension.  
So now we'll do the following sequence:
- rename the file with the ".bz2" extension
- decompressed it with **Bzip2**
- see the hexdump to check the actual file signature

```bash
bandit12@bandit:/tmp/ppm$ mv compressed_data compressed_data.bz2
bandit12@bandit:/tmp/ppm$ ls
compressed_data.bz2  hexdump_data
bandit12@bandit:/tmp/ppm$ bzip2 -d compressed_data.bz2
bandit12@bandit:/tmp/ppm$ ls
compressed_data  hexdump_data
bandit12@bandit:/tmp/ppm$ xxd compressed_data
00000000: 1f8b 0808 6855 1e65 0203 6461 7461 342e  ....hU.e..data4.
```
{: .nolineno }

As we can see, the file is now a **GZIP**, so let's rename it and decompress it again:

```bash
bandit12@bandit:/tmp/ppm$ mv compressed_data compressed_data.gz
bandit12@bandit:/tmp/ppm$ gzip -d compressed_data.gz
bandit12@bandit:/tmp/ppm$ ls
compressed_data  hexdump_data
bandit12@bandit:/tmp/ppm$ xxd compressed_data | head
00000000: 6461 7461 352e 6269 6e00 0000 0000 0000  data5.bin.......
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 3030 3030 3634 3400 3030 3030  ....0000644.0000
00000070: 3030 3000 3030 3030 3030 3000 3030 3030  000.0000000.0000
00000080: 3030 3234 3030 3000 3134 3530 3734 3532  0024000.14507452
00000090: 3535 3000 3031 3132 3437 0020 3000 0000  550.011247. 0...
```
{: .nolineno }

Search for the signature don't give me any conclusion, so let's try the **file** command to identify the file type:

```bash
bandit12@bandit:/tmp/ppm$ file compressed_data
compressed_data: POSIX tar archive (GNU)
```
{: .nolineno }

It's a **tar** archive file, so let's rename it, extract it and hexdump the result file:

```bash
bandit12@bandit:/tmp/ppm$ mv compressed_data compressed_data.tar
bandit12@bandit:/tmp/ppm$ tar -xf compressed_data.tar
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  hexdump_data
bandit12@bandit:/tmp/ppm$ xxd compressed_data | head
bandit12@bandit:/tmp/ppm$ xxd data5.bin | head
00000000: 6461 7461 362e 6269 6e00 0000 0000 0000  data6.bin.......
bandit12@bandit:/tmp/ppm$ file data5.bin
data5.bin: POSIX tar archive (GNU)
```
{: .nolineno }

Now we have another archive tar to decompress to data6.bin:

```bash
tar -xf data5.bin
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  data6.bin  hexdump_data
bandit12@bandit:/tmp/ppm$ file data6.bin
data6.bin: bzip2 compressed data, block size = 900k
```
{: .nolineno }

A **Bzip2** again, so lets repeat the process:

```bash
bandit12@bandit:/tmp/ppm$ bzip2 -d data6.bin our_file
bzip2: Can't guess original name for data6.bin -- using data6.bin.out
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  data6.bin.out  hexdump_data
```
{: .nolineno }

Repeating...

```bash
bandit12@bandit:/tmp/ppm$ bzip2 -d data6.bin
bzip2: Can't guess original name for data6.bin -- using data6.bin.out
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  data6.bin.out  hexdump_data
bandit12@bandit:/tmp/ppm$ file data6.bin.out
data6.bin.out: POSIX tar archive (GNU)
bandit12@bandit:/tmp/ppm$ tar -xf data6.bin.out
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  data6.bin.out  data8.bin  hexdump_data
bandit12@bandit:/tmp/ppm$ file data8.bin
data8.bin: gzip compressed data, was "data9.bin", last modified: Thu Oct  5 06:19:20 2023, max compression, from Unix, original size modulo 2^32 49
```
{: .nolineno }

file data8 still is a **GZIP** file, so let's extracted it, and check the typefile of the extracted file:

```bash
bandit12@bandit:/tmp/ppm$ mv data8.bin data8.gz
bandit12@bandit:/tmp/ppm$ gzip -d data8.gz
bandit12@bandit:/tmp/ppm$ ls
compressed_data.tar  data5.bin  data6.bin.out  data8  hexdump_data
bandit12@bandit:/tmp/ppm$ file data8
data8: ASCII text
```
{: .nolineno }

No we have a text file! Lets read it:

```bash
bandit12@bandit:/tmp/ppm$ cat data8
The password is wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw
```
{: .nolineno }

Now we have our password!

## Level 13 -> Level 14

### Login
```bash
ssh bandit13@bandit.labs.overthewire.org -p 2220
password:wbWdlBxEir4CaE8LaPhauuOo6pwRmrDw
```
{: .nolineno }

### Task
The password for the next level is stored in /etc/bandit_pass/bandit14 and can only be read by user bandit14. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level. Note: localhost is a hostname that refers to the machine you are working on

### MyWalk
Listing the initial directory we can see a "sshkey.private" file:

```bash
bandit13@bandit:~$ ls -al
total 24
drwxr-xr-x  2 root     root     4096 Oct  5 06:19 .
drwxr-xr-x 70 root     root     4096 Oct  5 06:20 ..
-rw-r--r--  1 root     root      220 Jan  6  2022 .bash_logout
-rw-r--r--  1 root     root     3771 Jan  6  2022 .bashrc
-rw-r--r--  1 root     root      807 Jan  6  2022 .profile
-rw-r-----  1 bandit14 bandit13 1679 Oct  5 06:19 sshkey.private
```
{: .nolineno }

Now lets transfer the "sshkey.private" file to our machine:

```bash
└─$ scp -P 2220 bandit13@bandit.labs.overthewire.org:sshkey.private . 
bandit13@bandit.labs.overthewire.org's password: 
sshkey.private                              100% 1679     9.3KB/s   00:00    
└─$ ls
sshkey.private
└─$ cat sshkey.private 
-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAxkkOE83W2cOT7IWhFc9aPaaQmQDdgzuXCv+ppZHa++buSkN+
gg0tcr7Fw8NLGa5+Uzec2rEg0WmeevB13AIoYp0MZyETq46t+jk9puNwZwIt9XgB
ZufGtZEwWbFWw/vVLNwOXBe4UWStGRWzgPpEeSv5Tb1VjLZIBdGphTIK22Amz6Zb
```
{: .nolineno }

Now we have the "sskey.private" file in our machine. Let's try to connect by ssh using this key file with option -i:

```bash
ssh -i sshkey.private bandit14@bandit.labs.overthewire.org -p 2220

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0640 for 'sshkey.private' are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
Load key "sshkey.private": bad permissions
```
{: .nolineno }

I need to adjust the file permissions, so only me has permissions for the file:

```bash
└─$ chmod 700 sshkey.private        
└─$ ls -al
total 12
drwxr-xr-x 2 ppmatrix ppmatrix 4096 Feb 10 08:53 .
drwxr-xr-x 3 ppmatrix ppmatrix 4096 Feb  3 07:59 ..
-rwx------ 1 ppmatrix ppmatrix 1679 Feb 10 08:53 sshkey.private
```
{: .nolineno }

Lets try again accessing with -i option:

```bash
└─$ ssh -i sshkey.private bandit14@bandit.labs.overthewire.org -p 2220
bandit14@bandit:~$ 
```
{: .nolineno }

Success! Now logged as bandit14

## Level 14 -> Level 15

### Login
Already logged from previous level.

### Task
The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost.

### MyWalk
First we'll do a nmap scan to check the services running on locahost:
```bash
bandit14@bandit:~$ nmap -T4 -sC -sV -Pn 127.0.0.1
Starting Nmap 7.80 ( https://nmap.org ) at 2024-02-10 14:24 UTC
(content omitted)
30000/tcp open  ndmps?
| fingerprint-strings: 
|   FourOhFourRequest, GenericLines, GetRequest, HTTPOptions, Help, Kerberos, LDAPSearchReq, LPDString, RTSPRequest, SIPOptions, SSLSessionReq, TLSSessionReq, TerminalServerCookie: 
|_    Wrong! Please enter the correct current password
(content omitted)
```
{: .nolineno }

Lets try connect to port 30000 on local host using **netcat**, and if a password is asked, we'll enter the bandit14 password:

```bash
bandit14@bandit:~$ cat /etc/bandit_pass//bandit14
fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq
bandit14@bandit:~$ nc localhost 30000
fGrHPx402xGC7U7rXKDaxiWFTOiF0ENq
Correct!
jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt

```
{: .nolineno }

## Level 15 -> Level 16

### Login
```bash
ssh bandit15@bandit.labs.overthewire.org -p 2220
password:jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt
```
{: .nolineno }

### Task
The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption.

Helpful note: Getting “HEARTBEATING” and “Read R BLOCK”? Use -ign_eof and read the “CONNECTED COMMANDS” section in the manpage. Next to ‘R’ and ‘Q’, the ‘B’ command also works in this version of that command…

### MyWalk
It seems we need to connect using SSL encrytion, so we'll try to use **openssl**:
```bash
bandit15@bandit:~$ openssl s_client -connect localhost:30001
CONNECTED(00000003)
(content omitted)
read R BLOCK
jN2kgmIXJ6fShzhT2avhotn4Zcka6tnt
Correct!
JQttfApK4SeyHwDlI9SXGR50qclOAil1

closed
```
{: .nolineno }

After "read R BLOCK" we inserted the current password and obtained the next one.

## Level 16 -> Level 17

### Login
```bash
ssh bandit16@bandit.labs.overthewire.org -p 2220
password:JQttfApK4SeyHwDlI9SXGR50qclOAil1
```
{: .nolineno }

### Task
The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.

### MyWalk
Lets try to catch the port with server with ssl, using nmap:
```bash
bandit16@bandit:~$ nmap -sV -p31000-32000 localhost
Starting Nmap 7.80 ( https://nmap.org ) at 2024-02-10 15:18 UTC
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00010s latency).
Not shown: 996 closed ports
PORT      STATE SERVICE     VERSION
31046/tcp open  echo
31518/tcp open  ssl/echo
31691/tcp open  echo
31790/tcp open  ssl/unknown
31960/tcp open  echo
```
{: .nolineno }

We got 5 ports running on the 31000-32000 range. 4 with echo and 1 ssl/unknown, Lets try to connect to 31790:

```bash
bandit16@bandit:~$ openssl s_client -connect localhost:31790
CONNECTED(00000003)
(content omitted)
read R BLOCK
JQttfApK4SeyHwDlI9SXGR50qclOAil1
Correct!
-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJ
(content omitted)
vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=
-----END RSA PRIVATE KEY-----

closed

```
{: .nolineno }

Current password inserted afted "read R BLOCK" and the result is a private key,

## Level 17 -> Level 18

### Login

Using the ssh key from the last level and saved as "level17key.private" file, saved on our machine lets login with -i option, but first we need to set permissions only to owner:

```bash
└─$ chmod 700 level17key.private
└─$ ssh -i level17key.private bandit17@bandit.labs.overthewire.org -p 2220
(content omitted)
bandit17@bandit:~$ 
```
{: .nolineno }

### Task
There are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new
NOTE: if you have solved this level and see ‘Byebye!’ when trying to log into bandit18, this is related to the next level, bandit19

### MyWalk
Lets use **diff** to find the changed line:

```bash
bandit17@bandit:~$ diff passwords.old passwords.new
42c42
< p6ggwdNHncnmCNxuAt0KtKVq185ZU7AW
---
> hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg
```
{: .nolineno }

The last one is the password.

## Level 18 -> Level 19

### Login

```bash
ssh bandit18@bandit.labs.overthewire.org -p 2220
password:hga5tuuCLF6fFzUpnagiMN8ssu9LFrdg
(content omitted)
Byebye !
Connection to bandit.labs.overthewire.org closed.
```
{: .nolineno }

It seems we can´t connect, as announced in the task description in previous level.  
So lets see the task for this level:

### Task
The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH.

### MyWalk
SSH does not just allows us to log into a remote machine. Also allows remote execution of commands.

First we'll do an **ls** command to lsit the files in bandit18 home directory::

```bash
ssh bandit18@bandit.labs.overthewire.org -p 2220 ls
(content omitted)
bandit18@bandit.labs.overthewire.org's password: 
readme
```
{: .nolineno }

Now lets see the content of "readme" file:

```bash
ssh bandit18@bandit.labs.overthewire.org -p 2220 cat readme
(content omitted)
bandit18@bandit.labs.overthewire.org's password: 
awhqfNnAbc1naukrpqDYcF95h7HoMTrC
```
{: .nolineno }

Another way is /bin/bash as a command to spawn a bash shell:

```bash
ssh bandit18@bandit.labs.overthewire.org -p 2220 /bin/bash
(content omitted)
bandit18@bandit.labs.overthewire.org's password: 
ls
readme
cat readme
awhqfNnAbc1naukrpqDYcF95h7HoMTrC
```
{: .nolineno }

## Level 19 -> Level 20

### Login

```bash
ssh bandit19@bandit.labs.overthewire.org -p 2220
password:awhqfNnAbc1naukrpqDYcF95h7HoMTrC
```
{: .nolineno }

### Task
To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary.

### MyWalk
Trying to run the binary:
```bash
bandit19@bandit:~$ ls -l
total 16
-rwsr-x--- 1 bandit20 bandit19 14876 Oct  5 06:19 bandit20-do
bandit19@bandit:~$ ./bandit20-do 
Run a command as another user.
  Example: ./bandit20-do id
```
{: .nolineno }

In this case, the owner is bandit20 and the group is bandit19, this with ‘-rwsr-x—’ means the user bandit19 can execute the binary, but the binary is executed as user bandit20.

Executing the binary says it simply executes another command as another user (as already explained, this user is bandit20). This means we can access the bandit20 users password file, which can only be read by the user bandit20.

```bash
bandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20
VxCazJaVykI6W36BkBU0mJTCM8rR95XT
```
{: .nolineno }

## Level 20 -> Level 21

### Login

```bash
ssh bandit20@bandit.labs.overthewire.org -p 2220
password:VxCazJaVykI6W36BkBU0mJTCM8rR95XT
```
{: .nolineno }

### Task
There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21).

### MyWalk
We can set a connection which listens for incoming connections with netcat. But we'll pipe an echo message containing the actual level password.  
Also we need to run this command in background so we can run the setuid binary, using &. The ampersand will send the command in the background. This is a part of the Linux process management. The -n flag is to prevent newline characters in the input:

```bash
bandit20@bandit:~$ echo -n 'VxCazJaVykI6W36BkBU0mJTCM8rR95XT' | nc -l -p 1234 &
[1] 3657263
bandit20@bandit:~$ ./suconnect 1234
Read: VxCazJaVykI6W36BkBU0mJTCM8rR95XT
Password matches, sending next password
NvEJF7oVjkddltPSrdKEFOllh9V1IBcq
[1]+  Done
```
{: .nolineno }

## Level 21 -> Level 22

### Login

```bash
ssh bandit21@bandit.labs.overthewire.org -p 2220
password:NvEJF7oVjkddltPSrdKEFOllh9V1IBcq
```
{: .nolineno }

### Task
A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed.

### MyWalk
lets see what the directory contains:

```bash
bandit21@bandit:~$ ls -al /etc/cron.d
total 56
drwxr-xr-x   2 root root  4096 Oct  5 06:20 .
drwxr-xr-x 106 root root 12288 Oct  5 06:20 ..
-rw-r--r--   1 root root    62 Oct  5 06:19 cronjob_bandit15_root
-rw-r--r--   1 root root    62 Oct  5 06:19 cronjob_bandit17_root
-rw-r--r--   1 root root   120 Oct  5 06:19 cronjob_bandit22
-rw-r--r--   1 root root   122 Oct  5 06:19 cronjob_bandit23
-rw-r--r--   1 root root   120 Oct  5 06:19 cronjob_bandit24
-rw-r--r--   1 root root    62 Oct  5 06:19 cronjob_bandit25_root
-rw-r--r--   1 root root   201 Jan  8  2022 e2scrub_all
-rwx------   1 root root    52 Oct  5 06:20 otw-tmp-dir
-rw-r--r--   1 root root   102 Mar 23  2022 .placeholder
-rw-r--r--   1 root root   396 Feb  2  2021 sysstat

```
{: .nolineno }

Now we'll check the cron configuration for bandit22:

```bash
bandit21@bandit:~$ cat /etc/cron.d/cronjob_bandit22
@reboot bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null
* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null
```
{: .nolineno }

5 stars means this job is running every minute and every day. To know what is executed, we need to take a look at the bash file:

```bash
bandit21@bandit:~$ cat /usr/bin/cronjob_bandit22.sh
#!/bin/bash
chmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
cat /etc/bandit_pass/bandit22 > /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
```
{: .nolineno }

This means a file is created in the tmp directory, is given read permissions to everyone (last 4 in chmod 644), and the password is writen in the new file.
We only need to read the file:

```bash
bandit21@bandit:~$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
WdDozAdTM2z9DiFEQ2mGlwngMfj4EZff
```
{: .nolineno }

## Level 22 -> Level 23

### Login

```bash
ssh bandit22@bandit.labs.overthewire.org -p 2220
password:WdDozAdTM2z9DiFEQ2mGlwngMfj4EZff
```
{: .nolineno }

### Task
A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed.

NOTE: Looking at shell scripts written by other people is a very useful skill. The script for this level is intentionally made easy to read. If you are having problems understanding what it does, try executing it to see the debug information it prints.

### MyWalk
As in last level we need to see what the is the job:

```bash
bandit22@bandit:~$ cat /etc/cron.d/cronjob_bandit23
@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null
* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null
bandit22@bandit:~$ cat /usr/bin/cronjob_bandit23.sh
#!/bin/bash

myname=$(whoami)
mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)

echo "Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget"

cat /etc/bandit_pass/$myname > /tmp/$mytarget
```
{: .nolineno }

$mytarget is the name of the file where the password is stored after each cronjob action. the whoami command result is his user (bandit22), so to read the file that contains the password, we'ĺl "build" the file name based on myname=$(whoami), and set $myname="bandit22", following by the next command (mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)) in the script, which return the md5 hash from the string:

```bash
bandit22@bandit:~$ echo $mytarget
8169b67bd894ddbb4412f91573b38db3
bandit22@bandit:~$ myname="bandit23"
bandit22@bandit:~$ mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)
bandit22@bandit:~$ cat /tmp/$mytarget
QYw0Y2aiA672PsMmh9puTQuhoz8SyR2G
```
{: .nolineno }

## Level 23 -> Level 24

### Login

```bash
ssh bandit23@bandit.labs.overthewire.org -p 2220
password:QYw0Y2aiA672PsMmh9puTQuhoz8SyR2G
```
{: .nolineno }

### Task
A program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed.

NOTE: This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level!

NOTE 2: Keep in mind that your shell script is removed once executed, so you may want to keep a copy around…

### MyWalk
Let's do the same steps to see the shell-script:

```bash
bandit23@bandit:~$ cat /etc/cron.d/cronjob_bandit24
@reboot bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null
* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null
bandit23@bandit:~$ cat /usr/bin/cronjob_bandit24.sh
#!/bin/bash

myname=$(whoami)

cd /var/spool/$myname/foo
echo "Executing and deleting all scripts in /var/spool/$myname/foo:"
for i in * .*;
do
    if [ "$i" != "." -a "$i" != ".." ];
    then
        echo "Handling $i"
        owner="$(stat --format "%U" ./$i)"
        if [ "${owner}" = "bandit23" ]; then
            timeout -s 9 60 ./$i
        fi
        rm -f ./$i
    fi
done
```
{: .nolineno }

we need to make a script to save the bandit24 password in a file accessible by us.
First we'll create a random temporary directory to work:

```bash
bandit23@bandit:~$ mktemp -d
/tmp/tmp.N6nLd1uS2b
bandit23@bandit:~$ cd /tmp/tmp.N6nLd1uS2b
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ ls -al
total 404
drwx------    2 bandit23 bandit23   4096 Feb 11 13:21 ./
drwxrwx-wt 2105 root     root     405504 Feb 11 13:21 ../
```
{: .nolineno }

Now we will create the our script to output the content of the password file to a file in our temporary directory. After that we will send the script to the directory referenced in the cronjob script which is wiped out each minute:

```bash
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ nano bandit24_pass.sh
```
{: .nolineno }

with file opened in nano let's type our script:

```bash
#!/bin/bash
cat /etc/bandit_pass/bandit24 > /tmp/tmp.N6nLd1uS2b/password
```
{: .nolineno }

save it and close nano.

We need now to give the permissions to our files, to be possible the user bandit24 execute the script file correctly:

```bash
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ chmod +rx bandit24_pass.sh 
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ chmod 777 /tmp/tmp.ljEyl6kv1M
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ touch password
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ chmod 777 password
```
{: .nolineno }

Now we'll make a copy of our script in the destination folder:

```bash
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ cp bandit24_pass.sh /var/spool/bandit24/foo/bandit24_pass.sh
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ ls -al
total 408
drwxrwxrwx    2 bandit23 bandit23   4096 Feb 11 14:11 ./
drwxrwx-wt 2132 root     root     405504 Feb 11 14:13 ../
-rwxrwxr-x    1 bandit23 bandit23     73 Feb 11 13:37 bandit24_pass.sh*
-rwxrwxrwx    1 bandit23 bandit23      0 Feb 11 13:23 password*
```
{: .nolineno }

The password file is actually empty. But after a minute we can see see some content in the password file:

```bash
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ ls -al
total 412
drwxrwxrwx    2 bandit23 bandit23   4096 Feb 11 14:11 .
drwxrwx-wt 2140 root     root     405504 Feb 11 14:38 ..
-rwxrwxr-x    1 bandit23 bandit23     73 Feb 11 13:37 bandit24_pass.sh
-rwxrwxrwx    1 bandit23 bandit23     33 Feb 11 14:14 password
bandit23@bandit:/tmp/tmp.N6nLd1uS2b$ cat password 
VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar
```
{: .nolineno }

## Level 24 -> Level 25

### Login

```bash
ssh bandit24@bandit.labs.overthewire.org -p 2220
password:VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar
```
{: .nolineno }

### Task
A daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing.
You do not need to create new connections each time

### MyWalk

There are several ways to do this. But i choose writing a script to store all the strings to try (<actual_password> + pin) in a file and then connect to server and send this strings to.

Open nano with file "brute_force.sh"
```bash
#!/bin/bash

for i in {0000..9999}
do
        echo VAfGXJ1PBSsPSnvsjI8p759leLZ9GGar $i >> pins_list.txt
done

cat pins_list.txt | nc localhost 30002 > response.txt
```
{: .nolineno }

Don't forget to make it executable:

```bash
chmod +x brute_force_pin.sh
```
{: .nolineno }

Now run the script:

```bash
bandit24@bandit:/tmp/tmp.RkGErYEFoT$ ./brute_force.sh
bandit24@bandit:/tmp/tmp.RkGErYEFoT$ sort result.txt | grep -v "Wrong!"
Correct!
Exiting.
I am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.
The password of user bandit25 is p7TaowMYrmu23Ol8hiZh9UvD0O9hpx8d
```
{: .nolineno }

I had some problems because the server stopped to answer after near 2000 tries. So I changed range in chunks of 1000 pins. The correct pin answer was found between 9000 and 9999. Later discovered that the range 0999..9999 also work!
